---
title: 复习排序算法笔记
date: 2016-11-11 12:10:00
categories:
- Coding
keywords:
- 排序算法
- Sorting algorithms
tags: 
- 基础知识
- 排序算法
- sorting algorithms
---

我最近开始复习排序算法，如其说是复习，倒不如说是学习。因为上学时没好好学，最熟悉的就只有 Bubble，之前念硕士的时候有用 Java 实现过一个关于 Bubble、Insert 和 Quick 这三个排序之间的可视化对比测试，然后就没有然后。工作一年后再来学基础，也算亡羊补牢。

先列一下我的学习资料：

- 程序员必知的8大排序系列：[(一)](http://blog.csdn.net/pzhtpf/article/details/7559896)、[(二)](http://blog.csdn.net/pzhtpf/article/details/7559943)、[(三)](http://blog.csdn.net/pzhtpf/article/details/7560294)   
  高手写的系列文章，介绍了常见八种排序算法的基本思想和 Java 实现
- VisualGO：[sorting](https://visualgo.net/sorting)  
  这是一个用来学习排序和数据结构非常好的网站，针对每一个排序实现有 step by step 的图形化实现步骤，让学习者更容易理解过程，而且还提供伪代码。

<!-- more -->

## 前言

由于我比较熟悉 PHP 和 JS，所以算法都会用这两种语言实现一遍。

为了测试算法，我准备了一份从0到999共1000个整数的乱序而成的JSON数组，以后所有代码中，这测试数据会在 PHP 中记作`$source`，在 JS 中记作 `source`。以下是数据内容：

```json
[195,137,876,281,711,119,963,740,357,941,603,208,691,756,874,240,872,563,956,354,774,619,385,386,786,985,216,482,77,418,165,614,605,759,239,559,83,397,796,129,978,487,168,888,480,318,992,549,709,317,987,913,36,172,772,896,782,451,439,522,970,452,705,980,254,677,0,99,123,419,112,764,91,192,244,878,817,107,643,14,507,988,333,478,801,230,408,89,841,512,202,949,779,58,41,656,891,835,897,760,905,434,213,305,366,313,827,703,19,8,97,378,517,828,784,453,672,179,269,738,20,667,899,813,503,976,712,850,424,229,964,295,206,289,588,336,823,787,360,85,93,421,623,504,826,920,210,287,2,972,127,875,662,1,264,194,422,879,925,514,228,902,163,342,593,135,498,608,401,28,319,235,149,915,188,205,807,324,918,506,344,552,449,316,867,124,693,863,117,462,391,341,436,583,840,420,923,198,154,834,246,595,440,328,490,880,625,443,916,718,322,600,406,84,610,849,680,332,947,541,553,744,933,818,814,425,260,671,616,719,175,450,869,800,914,430,327,881,865,647,253,126,975,669,86,661,60,340,685,937,982,742,500,515,692,412,648,997,768,193,904,601,641,570,845,457,928,22,763,189,27,34,46,296,393,525,59,694,456,717,232,66,379,780,805,467,283,701,864,790,589,182,812,837,732,943,466,557,646,267,679,411,226,757,953,103,950,637,698,11,477,984,474,100,727,33,546,699,969,769,486,747,816,241,306,17,162,924,765,652,540,597,293,446,63,792,40,722,261,674,562,329,144,938,102,215,737,37,143,746,414,152,802,806,87,542,494,811,479,894,773,804,458,396,104,472,247,990,720,883,657,278,602,395,748,465,79,704,655,372,967,469,644,282,358,501,211,325,416,347,221,110,176,639,793,298,158,725,145,579,866,706,116,544,654,868,955,898,750,707,954,971,272,789,998,604,810,513,870,377,185,575,220,686,484,380,974,621,696,626,960,288,338,919,543,155,69,6,927,139,279,856,349,251,596,965,752,664,96,505,708,829,51,285,138,161,638,758,108,715,739,47,584,788,314,942,429,394,771,225,248,31,683,122,753,681,566,981,426,592,249,545,214,368,594,442,986,658,88,633,620,636,209,171,250,413,702,218,157,156,751,561,531,795,666,284,257,431,968,72,12,917,147,613,331,948,376,710,889,204,776,109,146,309,301,35,631,242,855,24,745,160,174,567,822,836,481,197,445,491,461,695,61,723,438,361,973,183,903,825,62,853,979,118,931,64,901,263,830,530,403,134,518,132,485,7,910,659,292,191,454,640,392,731,803,270,885,265,128,926,409,961,26,303,231,350,382,716,444,921,16,645,224,539,576,520,663,951,114,359,824,207,649,130,38,410,150,140,459,767,68,113,308,735,534,323,618,791,729,167,871,74,320,315,255,23,428,565,728,726,516,700,177,65,615,962,673,906,76,364,989,427,775,993,388,736,441,799,374,470,492,839,463,843,538,334,821,550,53,886,373,473,307,297,120,29,957,234,994,304,170,564,932,587,199,18,586,650,554,873,9,190,355,136,493,676,294,624,187,252,266,80,370,290,510,577,653,180,67,186,273,268,383,25,3,236,148,447,670,713,877,578,398,381,551,582,511,45,375,111,599,697,275,509,766,345,893,489,632,521,527,259,276,983,907,274,819,497,781,98,724,133,30,555,755,528,217,844,173,417,944,95,365,908,977,778,460,13,721,389,256,390,404,4,627,115,348,196,535,862,70,178,277,858,838,203,369,848,611,81,952,678,121,529,831,832,675,846,537,346,777,262,861,991,437,448,363,996,131,371,302,607,854,78,690,581,384,299,536,743,900,321,464,815,665,164,222,343,92,286,612,496,642,105,995,922,330,820,966,337,573,233,749,44,519,407,49,468,353,223,291,939,488,311,882,335,75,783,571,432,483,526,580,809,622,798,423,852,258,50,435,548,568,999,860,54,57,687,184,585,598,851,714,159,245,5,634,508,312,48,730,547,785,660,400,651,560,387,433,591,356,82,572,940,310,181,762,352,94,212,770,455,628,734,415,635,590,606,682,668,934,73,153,945,106,15,227,887,32,362,21,935,688,405,689,884,90,569,499,558,502,39,42,946,151,741,890,859,471,629,532,10,909,142,857,141,929,808,895,219,617,556,55,754,326,125,399,959,71,475,533,523,847,243,43,237,280,271,339,476,684,402,101,794,166,52,201,733,200,351,169,842,238,912,367,833,56,911,930,524,609,300,495,630,958,761,892,797,574,936]
```

## 1. 冒泡排序 (Bubble sort)

冒泡排序的逻辑包含两层循环：

1. 里面一层循环用来比较第 N 个元素和第 N+1 个元素，假如 N+1 比 N 小，那么两者交换位置，然后一直比较至该循环可达到的最后一个元素。其目的是在一次循环中将所有参与比较元素中最重（最大）的元素先沉（放）到最底（最右边），然后让其他较轻（较小）的元素逐渐浮（挪）到上面（左边）；
2. 外面一层循环用来设定里面一层循环的范围，使其每次循环的范围都减一。因为前一次循环已经将其中最重(最大)的元素沉（放）到最底（最右边）了，所以下一次循环就可以接着比较剩下的元素。

### PHP 实现：

```php
for ($i = 0; $i < count($source) - 1; $i ++) {
    for ($j = 0; $j < count($source) - (1 + $i); $j ++) {
       if ($source[$j] > $source[$j + 1]) {
          $temp = $source[$j];
          $source[$j] = $source[$j + 1];
          $source[$j + 1] = $temp;
       }
    }
}
```

完整代码：[PHP Sandbox](http://sandbox.onlinephpfunctions.com/code/710d1348f838f69bc52dfa93a1595d76e401e742)
耗时：49-55ms (PHP v7.0.5)

### JS 实现

```js
var temp = null;
var sourceLength = source.length;
for (var i = 0; i < sourceLength - 1; i ++) {
    for (var j = 0; j < sourceLength - (1 + i); j ++) {
        if (source[j] > source[j+1]) {
            temp = source[j];
            source[j] = source[j+1];
            source[j+1] = temp;         
        }
    }
}
```

完整代码：

<p data-height="265" data-theme-id="dark" data-slug-hash="rWjzjN" data-default-tab="js,result" data-user="leo_li" data-embed-version="2" data-pen-title="Bubble sort" class="codepen">See the Pen <a href="https://codepen.io/leo_li/pen/rWjzjN/">Bubble sort</a> by Leo LI (<a href="http://codepen.io/leo_li">@leo_li</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

### 冒泡排序的改良版

看过 VisualGO 给出的伪代码后有所启发，感觉性能应该能更好一点。先上伪代码：

```
do
    swapped = false
    for i = 1 to indexOfLastUnsortedElement
    if leftElement > rightElement
        swap(leftElement, rightElement)
        swapped = true
while swapped
```

假设原数组是`1,2,3,4,5,7,6`，其实排序过程只是将最后两个数`7`和`6`对换了一下位置，但用之前的方法就会有很多不必要的循环和比较，用上新方法后就能有效减少这些步骤。

### PHP 实现：

```php
$swapped = false;
$indexOfLastUnsortedElement = count($source) - 1;
do {
    $swapped = false;    
    for ($i = 0; $i < $indexOfLastUnsortedElement; $i++) {
        if ($source[$i] > $source[$i + 1]) {
            $temp = $source[$i];
            $source[$i] = $source[$i + 1];
            $source[$i + 1] = $temp;
            $swapped = true;
        }
    }
    $indexOfLastUnsortedElement--;
} while ($swapped);
```

完整代码：[PHP Sandbox](http://sandbox.onlinephpfunctions.com/code/287ac9aac352e94116b420cfc0e537c500cabeb3)
耗时：34-37ms (PHP v7.0.5) **优化效果明显！**

### JS 实现:

```js
var temp = null;
var indexOfLastUnsortedElement = source.length - 1;
var swapped = null;
do {
   swapped = false;
   for (var i = 0; i < indexOfLastUnsortedElement; i++) {
       if (source[i] > source[i + 1]) {
           temp = source[i];
           source[i] = source[i + 1];
           source[i + 1] = temp;
           swapped = true;
       }	        
   }
   indexOfLastUnsortedElement--;
} while (swapped);
```

完整代码：

<p data-height="265" data-theme-id="dark" data-slug-hash="xRgYNa" data-default-tab="js,result" data-user="leo_li" data-embed-version="2" data-pen-title="Bubble sort v2" class="codepen">See the Pen <a href="https://codepen.io/leo_li/pen/xRgYNa/">Bubble sort v2</a> by Leo LI (<a href="http://codepen.io/leo_li">@leo_li</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

（不知道为什么在 JS 中这个改进算法没任何显著优化效果，而且在不同浏览器中测试结果也不一样，在 Safari 中的测试速度要远好于 Chrome）

---

持续更新中...

